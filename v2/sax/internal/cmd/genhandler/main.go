package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"unicode"

	"github.com/lestrrat-go/codegen"
	"github.com/pkg/errors"
)

type argdef struct {
	name string
	typ  string
}

type retdef struct {
	zeroval string
	typ     string
}

type handlerdef struct {
	args []*argdef
	name string
	ret  []*retdef
}

var handlers = []*handlerdef{
	{
		name: "AttributeDecl",
		args: []*argdef{
			{name: "elem", typ: "string"},
			{name: "fullname", typ: "string"},
			{name: "typ", typ: "int"},
			{name: "def", typ: "int"},
			{name: "defaultValue", typ: "string"},
			{name: "tree", typ: "Enumeration"},
		},
	},
	{
		name: "CDataBlock",
		args: []*argdef{
			{name: "value", typ: "[]byte"},
		},
	},
	{
		name: "Characters",
		args: []*argdef{
			{name: "ch", typ: "[]byte"},
		},
	},
	{
		name: "Comment",
		args: []*argdef{
			{name: "value", typ: "[]byte"},
		},
	},
	{
		name: "EndDocument",
	},
	{
		name: "EndElementNS",
		args: []*argdef{
			{name: "localname", typ: "string"},
			{name: "prefix", typ: "string"},
			{name: "uri", typ: "string"},
		},
	},
	{
		name: "EntityDecl",
		args: []*argdef{
			{name: "name", typ: "string"},
			{name: "typ", typ: "int"},
			{name: "publicID", typ: "string"},
			{name: "sysytemID", typ: "string"},
			{name: "content", typ: "string"},
		},
	},
	{
		name: "Error",
		args: []*argdef{
			{name: "message", typ: "string"},
			{name: "args", typ: "...interface{}"},
		},
	},
	{
		name: "ExternalSubset",
		args: []*argdef{
			{name: "name", typ: "string"},
			{name: "externalID", typ: "string"},
			{name: "systemID", typ: "string"},
		},
	},
	{
		name: "GetEntity",
		args: []*argdef{
			{name: "name", typ: "string"},
		},
		ret: []*retdef{
			{zeroval: "nil", typ: "Entity"},
		},
	},
	{
		name: "GetParameterEntity",
		args: []*argdef{
			{name: "name", typ: "string"},
		},
		ret: []*retdef{
			{zeroval: "nil", typ: "Entity"},
		},
	},
	{
		name: "HasExternalSubset",
		ret: []*retdef{
			{zeroval: "false", typ: "bool"},
		},
	},
	{
		name: "HasInternalSubset",
		ret: []*retdef{
			{zeroval: "false", typ: "bool"},
		},
	},
	{
		name: "IgnorableWhitespace",
		args: []*argdef{
			{name: "ch", typ: "[]byte"},
		},
	},
	{
		name: "InternalSubset",
		args: []*argdef{
			{name: "name", typ: "string"},
			{name: "externalID", typ: "string"},
			{name: "systemID", typ: "string"},
		},
	},
	{
		name: "IsStandalone",
		ret: []*retdef{
			{zeroval: "false", typ: "bool"},
		},
	},
	{
		name: "NotationDecl",
		args: []*argdef{
			{name: "name", typ: "string"},
			{name: "publicID", typ: "string"},
			{name: "systemID", typ: "string"},
		},
	},
	{
		name: "ProcessingInstruction",
		args: []*argdef{
			{name: "target", typ: "string"},
			{name: "data", typ: "string"},
		},
	},
	{
		name: "Reference",
		args: []*argdef{
			{name: "name", typ: "string"},
		},
	},
	{
		name: "ResolveEntity",
		args: []*argdef{
			{name: "publicID", typ: "string"},
			{name: "systemID", typ: "string"},
		},
		ret: []*retdef{
			{zeroval: "nil", typ: "ParseInput"},
		},
	},
	{
		name: "SetDocumentLocator",
		args: []*argdef{
			{name: "locator", typ: "DocumentLocator"},
		},
	},
	{
		name: "StartDocument",
	},
	{
		name: "StartElementNS",
		args: []*argdef{
			{name: "localname", typ: "string"},
			{name: "prefix", typ: "string"},
			{name: "uri", typ: "string"},
			{name: "namespaces", typ: "[]Namespace"},
			{name: "attributes", typ: "[]Attribute"},
		},
	},
	{
		name: "UnparsedEntityDecl",
		args: []*argdef{
			{name: "name", typ: "string"},
			{name: "publicID", typ: "string"},
			{name: "systemID", typ: "string"},
			{name: "notationName", typ: "string"},
		},
	},
}

func main() {
	if err := _main(); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	}
}

func _main() error {
	if err := genInterface(); err != nil {
		return errors.Wrap(err, `failed to generate interface`)
	}
	if err := genHandler(); err != nil {
		return errors.Wrap(err, `failed to generate handler`)
	}
	return nil
}

func printReturnTypes(dst io.Writer, retdefs []*retdef) {
	if len(retdefs) == 0 {
		fmt.Fprintf(dst, "error")
		return
	}

	fmt.Fprintf(dst, "(")
	for i, ret := range retdefs {
		if i > 0 {
			fmt.Fprintf(dst, ",")
		}
		fmt.Fprintf(dst, "%s", ret.typ)
	}
	fmt.Fprintf(dst, ", error)")
}

func genInterface() error {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// This file is auto-generated by internal/cmd/genhandler/main.go. DO NOT EDIT")
	fmt.Fprintf(&buf, "\n\npackage sax")
	fmt.Fprintf(&buf, "\n\nvar ErrHandlerUnimplemented = errors.New(`handler is unimplemented`)")

	fmt.Fprintf(&buf, "\n\ntype DocumentLocator interface{} // TODO")
	fmt.Fprintf(&buf, "\n\ntype Entity interface{")
	fmt.Fprintf(&buf, "\nName() string")
	fmt.Fprintf(&buf, "\nSetOrig(string)")
	fmt.Fprintf(&buf, "\nEntityType() int")
	fmt.Fprintf(&buf, "\nContent() []byte")
	fmt.Fprintf(&buf, "\nChecked() bool")
	fmt.Fprintf(&buf, "\nMarkChecked()")
	fmt.Fprintf(&buf, "\n}")

	fmt.Fprintf(&buf, "\n\ntype Enumeration interface{}")
	fmt.Fprintf(&buf, "\n\ntype ParseInput interface{} // TODO")
	fmt.Fprintf(&buf, "\n\ntype UserData interface{}")
	fmt.Fprintf(&buf, "\n\ntype Namespace interface {")
	fmt.Fprintf(&buf, "\nPrefix() string")
	fmt.Fprintf(&buf, "\nURI() string")
	fmt.Fprintf(&buf, "\n}")
	fmt.Fprintf(&buf, "\n\ntype Attribute interface {")
	fmt.Fprintf(&buf, "\nLocalName() string")
	fmt.Fprintf(&buf, "\nName() string")
	fmt.Fprintf(&buf, "\nPrefix() string")
	fmt.Fprintf(&buf, "\nValue() string")
	fmt.Fprintf(&buf, "\nIsDefault() bool")
	fmt.Fprintf(&buf, "\n}")
	for _, hdef := range handlers {
		fmt.Fprintf(&buf, "\n\ntype %sHandler interface {", hdef.name)
		fmt.Fprintf(&buf, "\n%s(UserData", hdef.name)
		for _, arg := range hdef.args {
			fmt.Fprintf(&buf, ", %s", arg.typ)
		}
		fmt.Fprintf(&buf, ") ")
		printReturnTypes(&buf, hdef.ret)
		fmt.Fprintf(&buf, "\n}")
	}

	fmt.Fprintf(&buf, "\n\n// Handler is a complete SAX2 handler that can react to all")
	fmt.Fprintf(&buf, "\n// possible event types. If the paticular event is not handled")
	fmt.Fprintf(&buf, "\n// a ErrHandlerUnimplemented error will be returned")
	fmt.Fprintf(&buf, "\ntype Handler interface {")
	for _, hdef := range handlers {
		fmt.Fprintf(&buf, "\n%sHandler", hdef.name)
	}
	fmt.Fprintf(&buf, "\n}")

	if err := codegen.WriteFile("interface_gen.go", &buf, codegen.WithFormatCode(true)); err != nil {
		if cfe, ok := err.(codegen.CodeFormatError); ok {
			fmt.Fprint(os.Stderr, cfe.Source())
		}
		return errors.Wrap(err, `failed to write to interface_gen.go`)
	}
	return nil
}

func genHandler() error {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// This file is auto-generated by internal/cmd/genhandler/main.go. DO NOT EDIT")
	fmt.Fprintf(&buf, "\n\npackage sax")

	fmt.Fprintf(&buf, "\n\ntype sax2 struct {")
	for _, hdef := range handlers {
		// DON'T DO THIS AT HOME, BOYS AND GIRLS!
		fmt.Fprintf(&buf, "\n%c%s %sHandler", unicode.ToLower(rune(hdef.name[0])), hdef.name[1:], hdef.name)
	}
	fmt.Fprintf(&buf, "\n}")
	fmt.Fprintf(&buf, "\nvar _ Handler = &sax2{}")

	fmt.Fprintf(&buf, "\n\n// SAX2 creates a new instance of a generic SAX2 handler from the")
	fmt.Fprintf(&buf, "\n// provided handler object.")
	fmt.Fprintf(&buf, "\n//")
	fmt.Fprintf(&buf, "\n// The new object will delegate work to the original handler where")
	fmt.Fprintf(&buf, "\n// appropriate, and for everything else that is not implemented it will")
	fmt.Fprintf(&buf, "\n// return a ErrHandlerUnimplemented error")
	fmt.Fprintf(&buf, "\nfunc SAX2(v interface{}) Handler {")
	fmt.Fprintf(&buf, "\ns := &sax2{}")
	for _, hdef := range handlers {
		fmt.Fprintf(&buf, "\nif h, ok := v.(%sHandler); ok {", hdef.name)
		fmt.Fprintf(&buf, "\ns.%c%s = h", unicode.ToLower(rune(hdef.name[0])), hdef.name[1:])
		fmt.Fprintf(&buf, "\n}")
	}
	fmt.Fprintf(&buf, "\nreturn s")
	fmt.Fprintf(&buf, "\n}")

	for _, hdef := range handlers {
		fmt.Fprintf(&buf, "\n\nfunc (s *sax2) %s(ud UserData", hdef.name)
		for _, arg := range hdef.args {
			fmt.Fprintf(&buf, ", %s %s", arg.name, arg.typ)
		}
		fmt.Fprintf(&buf, ") ")
		printReturnTypes(&buf, hdef.ret)
		fmt.Fprintf(&buf, " {")
		fmt.Fprintf(&buf, "\nif h := s.%c%s; h != nil {", unicode.ToLower(rune(hdef.name[0])), hdef.name[1:])
		fmt.Fprintf(&buf, "\nreturn h.%s(ud, ", hdef.name)
		for i, arg := range hdef.args {
			if i > 0 {
				fmt.Fprintf(&buf, ",")
			}
			fmt.Fprintf(&buf, "%s", arg.name)
		}
		fmt.Fprintf(&buf, ")")
		fmt.Fprintf(&buf, "\n}")

		fmt.Fprintf(&buf, "\nreturn ")
		if retdefs := hdef.ret; len(retdefs) > 0 {
			for _, ret := range retdefs {
				fmt.Fprintf(&buf, "%s, ", ret.zeroval)
			}
		}
		fmt.Fprintf(&buf, "ErrHandlerUnimplemented")
		fmt.Fprintf(&buf, "\n}")
	}

	if err := codegen.WriteFile("sax2_gen.go", &buf, codegen.WithFormatCode(true)); err != nil {
		if cfe, ok := err.(codegen.CodeFormatError); ok {
			fmt.Fprint(os.Stderr, cfe.Source())
		}
		return errors.Wrap(err, `failed to write to sax2_gen.go`)
	}
	return nil
}
