package main

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/lestrrat-go/codegen"
	"github.com/lestrrat-go/xstrings"
	"github.com/pkg/errors"
)

func main() {
	if err := _main(); err != nil {
		fmt.Printf("%s\n", err)
		os.Exit(1)
	}
}

type nodedef struct {
	fields            []*fielddef
	skipFields        bool
	skipElementFields bool
	skipAddChild      bool
	skipAddContent    bool
	skipAddSibling    bool
	skipReplace       bool
}

type fielddef struct {
	name string
	get  string
	set  string
	typ  string
}

var nodes = map[string]*nodedef{
	"Attribute": {
		skipElementFields: true,
		fields: []*fielddef{
			{
				name: "atype",
				typ:  "AttributeType",
			},
			{
				name: "defaultAttr",
				get:  "IsDefault",
				set:  "SetDefault",
				typ:  "bool",
			},
			{
				name: "ns",
				typ:  "*Namespace",
			},
		},
	},
	"Comment": {},
	"DTD": {
		skipElementFields: true,
		fields: []*fielddef{
			{
				name: "attributes",
				typ:  "map[string]*AttributeDecl",
			},
			{
				name: "elements",
				typ:  "map[string]*ElementDecl",
			},
			{
				name: "entities",
				typ:  "map[string]*Entity",
			},
			{
				name: "pentities",
				typ:  "map[string]*Entity",
			},
		},
	},
	"Document": {
		fields: []*fielddef{
			{name: "version",
				typ: "string",
			},
			{name: "encoding",
				typ: "string",
			},
			{name: "standalone",
				typ: "DocumentStandaloneType",
			},
			{name: "intSubset",
				typ: "*DTD",
			},
			{name: "extSubset",
				typ: "*DTD",
			},
		},
	},
	"Element": {},
	"Entity": {
		fields: []*fielddef{
			// Note to future self: the original libxml2 code had this
			//   "content    string     // content or ndata if unparsed"
			// ndata...? we don't do ndata (at least I don't remember
			// writing it that way. maybe we have bugs around this)
			{name: "orig", typ: "string"}, // content without substitution
			{
				name: "entityType",
				typ:  "EntityType",
				get:  "EntityType",
			}, // the entity type
			{name: "externalID", typ: "string"}, // external identifier for PUBLIC
			{name: "systemID", typ: "string"},   // URI for a SYSTEM or PUBLIC entity
			{name: "uri", typ: "string"},        // the full URI as computed
			{name: "owner", typ: "bool"},        // does the entity own children
			{name: "checked", typ: "int"},       // was the entity content checked
		},
	},
	"EntityRef": {},
	"Namespace": {
		fields: []*fielddef{
			{name: "href",
				get: "URI",
				typ: "string",
			},
			{name: "prefix",
				get: "Prefix",
				typ: "string",
			},
			{name: "context",
				typ: "*Document",
			},
		},
	},
	"ProcessingInstruction": {
		skipElementFields: true,
		fields: []*fielddef{
			{name: "target",
				typ: "string",
			},
			{name: "data",
				typ: "string",
			},
		},
	},
	"Text": {
		skipAddChild:   true,
		skipAddContent: true,
	},
}

func _main() error {
	basicfields := []*fielddef{
		{name: "name",
			get: "LocalName",
			typ: "string",
		},
		{name: "firstChild",
			get: "FirstChild",
			set: "setFirstChild",
			typ: "Node",
		},
		{name: "lastChild",
			get: "LastChild",
			set: "setLastChild",
			typ: "Node",
		},
		{name: "parent",
			get: "Parent",
			set: "SetParent",
			typ: "Node",
		},
		{name: "next",
			get: "NextSibling",
			set: "SetNextSibling",
			typ: "Node",
		},
		{name: "prev",
			get: "PrevSibling",
			set: "SetPrevSibling",
			typ: "Node",
		},
		{name: "doc",
			get: "OwnerDocument",
			set: "SetOwnerDocument",

			typ: "*Document",
		},
	}

	elementfields := []*fielddef{
		{name: "private",
			typ: "interface{}",
		},
		{name: "content",
			get: "Content",
			typ: "[]byte",
		},
		{name: "properties",
			typ: "*Attribute",
		},
		{name: "ns",
			typ: "*Namespace",
		},
		{name: "nsDefs",
			typ: "[]*Namespace",
		},
	}

	var nodenames []string
	for name, def := range nodes {
		nodenames = append(nodenames, name)

		if !def.skipFields {
			for _, fdef := range basicfields {
				if name == "Document" && fdef.name == "doc" {
					continue
				}
				def.fields = append(def.fields, fdef)
			}
			if !def.skipElementFields {
				for _, fdef := range elementfields {
					def.fields = append(def.fields, fdef)
				}
			}
		}

		sort.Slice(def.fields, func(i, j int) bool {
			return def.fields[i].name < def.fields[j].name
		})
	}
	sort.Strings(nodenames)

	for _, name := range nodenames {
		def := nodes[name]
		if err := genNodeDefinition(name, def); err != nil {
			return errors.Wrapf(err, `failed to generate node %s`, name)
		}
	}
	return nil
}

func genNodeDefinition(name string, def *nodedef) error {
	lcname := strings.ToLower(name)
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// This file is auto-generated by internal/cmd/gennodes/main.go. DO NOT EDIT")
	fmt.Fprintf(&buf, "\n\npackage helium")

	fmt.Fprintf(&buf, "\n\ntype %s struct {", name)
	for _, fdef := range def.fields {
		fmt.Fprintf(&buf, "\n%s %s", fdef.name, fdef.typ)
	}
	fmt.Fprintf(&buf, "\n}")

	fmt.Fprintf(&buf, "\n\nfunc (*%s) Type() ElementType {", name)
	fmt.Fprintf(&buf, "\nreturn %sNode", name)
	fmt.Fprintf(&buf, "\n}")

	for _, fdef := range def.fields {
		if method := fdef.get; method != "" {
			fmt.Fprintf(&buf, "\n\nfunc (n *%s) %s() %s {", name, method, fdef.typ)
			fmt.Fprintf(&buf, "\nreturn n.%s", fdef.name)
			fmt.Fprintf(&buf, "\n}")
		}

		if method := fdef.set; method != "" {
			fmt.Fprintf(&buf, "\n\nfunc (n *%s) %s(v %s) {", name, method, fdef.typ)
			fmt.Fprintf(&buf, "\nn.%s = v", fdef.name)
			fmt.Fprintf(&buf, "\n}")
		}
	}

	if !def.skipAddChild {
		fmt.Fprintf(&buf, "\n\nfunc (n *%s) AddChild(c Node) error {", name)
		fmt.Fprintf(&buf, "\nreturn addChild(n, c)")
		fmt.Fprintf(&buf, "\n}")
	}

	if !def.skipAddContent {
		fmt.Fprintf(&buf, "\n\nfunc (n *%s) AddContent(b []byte) error {", name)
		fmt.Fprintf(&buf, "\nreturn addContent(n, b)")
		fmt.Fprintf(&buf, "\n}")
	}

	if !def.skipAddSibling {
		fmt.Fprintf(&buf, "\n\nfunc (n *%s) AddSibling(c Node) error {", name)
		fmt.Fprintf(&buf, "\nreturn addSibling(n, c)")
		fmt.Fprintf(&buf, "\n}")
	}

	if def.skipElementFields {
		fmt.Fprintf(&buf, "\n\nfunc (n *%s) Content() []byte {", name)
		fmt.Fprintf(&buf, "\nreturn getContent(n)")
		fmt.Fprintf(&buf, "\n}")
	}

	if !def.skipReplace {
		fmt.Fprintf(&buf, "\n\nfunc (n *%s) Replace(v Node) {", name)
		fmt.Fprintf(&buf, "\nreplaceNode(n, v)")
		fmt.Fprintf(&buf, "\n}")
	}

	if err := codegen.WriteFile(xstrings.Snake(name)+"_gen.go", &buf, codegen.WithFormatCode(true)); err != nil {
		if cfe, ok := err.(codegen.CodeFormatError); ok {
			fmt.Fprint(os.Stderr, cfe.Source())
		}
		return errors.Wrapf(err, `failed to write to %s_gen.go`, lcname)
	}
	return nil
}
